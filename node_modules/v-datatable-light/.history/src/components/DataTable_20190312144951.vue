<template>
    <table class="v-datatable-light-header" :class="css.tableHeader">
      <thead :class="css.thead">
        <tr :class="css.theadTr" style="display:block;">
          <th 
            v-for="(item, index) in headers"
            :key="item.label"
            :class="headerItemClass(item, css.th)"
            style="width:150px;"
          >
            <div
              v-if="!isFieldSpecial(item.name)"
              :class="css.thWrapper"
              @click="orderBy(item.name)"
            >
              {{ item.label }}
              <div v-if="item.sortable" :class="arrowsWrapper(item.name, css.arrowsWrapper)">
                <div
                  v-if="(sortedField !== item.name) || (sortedField === item.name && sortedDir === 'desc')"
                  :class="css.arrowUp"
                />
                <div
                  v-if="(sortedField !== item.name) || (sortedField === item.name && sortedDir === 'asc')"
                  :class="css.arrowDown"
                />
              </div>
            </div>
            <div
              v-if="isFieldSpecial(item.name) && extractArgs(item.name) === 'checkboxes'"
              :class="css.thWrapperCheckboxes"
            >
              <input
                type="checkbox"
                :class="css.checkboxHeader"
                :checked="checkedAll"
                @click="checkAll"
              >
            </div>
          </th>
        </tr>
      </thead>
      <tbody :class="css.tbody">
        <template v-if="isLoading">
          <tr :class="css.tbodyTrSpinner">
            <td :colspan="headers.length" :class="css.tbodyTdSpinner">
              <slot name="spinner"/>
            </td>
          </tr>
        </template>
        <template v-else-if="data.length">
          <tr v-for="(item, index) in data" :key="index" :class="css.tbodyTr">
            <td 
              v-for="key in headers"
              :key="`${index}-${key.name}`"
              :class="css.tbodyTd" 
              style="width:150px;"
              >
              <slot
                v-if="isFieldSpecial(key.name) && extractArgs(key.name) === 'actions'"
                :name="extractArgs(key.name)"
                :row-data="item"
                :row-index="index"
              />
              <input
                v-if="isFieldSpecial(key.name) && extractArgs(key.name) === 'checkboxes'"
                type="checkbox"
                :class="css.checkbox"
                :row-data="item"
                :row-index="index"
                :checked="checkedAll || isCheckedItem(item)"
                @click="checkItem(item, $event)"
              >
              <template v-else-if="key.format">{{ key.format(item[key.name]) }}</template>
              <template v-else>{{ item[key.name] }}</template>
            </td>
          </tr>
        </template>
        <template v-else>
          <tr :class="css.notFoundTr">
            <td :colspan="headers.length" :class="css.notFoundTd">{{ notFoundMessage }}</td>
          </tr>
        </template>
      </tbody>
      <tfoot v-if="hasSlots" :class="css.tfoot">
        <tr :class="css.tfootTr">
          <th :colspan="headers.length" :class="css.tfootTd">
            <div :class="css.footer">
              <slot name="ItemsPerPage"/>
              <slot name="pagination"/>
            </div>
          </th>
        </tr>
      </tfoot>
    </table>
</template>
<script>
export default {
  name: "DataTable",
  props: {
    headerFields: {
      type: Array,
      required: true
    },
    data: {
      type: Array,
      required: true
    },
    isLoading: {
      type: Boolean,
      default: false
    },
    sortField: {
      type: String,
      default: null
    },
    sort: {
      type: String,
      default: null
    },
    notFoundMsg: {
      type: String,
      default: null
    },
    trackBy: {
      type: String,
      default: "id"
    },
    css: {
      type: Object,
      default: () => ({
        tableHeader: "",
        tableBody: "",
        thead: "",
        theadTr: "",
        th: "",
        tbody: "",
        tbodyTr: "",
        tbodyTrSpinner: "",
        tbodyTd: "",
        tbodyTdSpinner: "",
        tfoot: "",
        tfootTh: "",
        tfootTr: "",
        footer: "",
        thWrapper: "",
        thWrapperCheckboxes: "",
        arrowsWrapper: "",
        arrowUp: "",
        arrowDown: "",
        checkboxHeader: "",
        checkbox: "",
        notFoundTr: "",
        notFoundTd: ""
      })
    }
  },

  data: function() {
    return {
      sortedField: this.sortField,
      sortedDir: this.sort,
      notFoundMessage: this.notFoundMsg,
      loading: this.isLoading,
      checkedAll: false,
      itemsChecked: []
    };
  },

  computed: {
    hasSlots: function() {
      return (
        this.$slots.pagination !== undefined ||
        this.$slots.ItemsPerPage !== undefined
      );
    },

    headers: function() {
      if (
        this.headerFields &&
        this.headerFields.constructor === Array &&
        this.headerFields.length
      ) {
        return Object.keys(this.headerFields).map(key => {
          const field = this.headerFields[key];
          if (typeof field === "string") {
            return { label: field, name: field };
          }
          return field;
        });
      }
      return [];
    }
  },

  methods: {
    arrowsWrapper: function(field, className) {
      if (this.sortedField === field && this.sortedDir) {
        return `${className} centralized`;
      }
      return className;
    },

    updateData: function() {
      const params = {
        sortField: this.sortedField,
        sort: this.sortedDir
      };

      this.$emit("onUpdate", params);
    },

    orderBy: function(field) {
      if (this.isFieldSortable(field)) {
        if (this.sortedField === field) {
          this.sortedDir = this.sortedDir === "asc" ? "desc" : "asc";
        } else {
          this.sortedDir = "desc";
          this.sortedField = field;
        }
        this.updateData();
      }
    },

    checkAll: function() {
      this.checkedAll = !this.checkedAll;
      if (this.checkedAll) {
        this.itemsChecked = this.data;
      } else {
        this.itemsChecked = [];
      }
      this.$emit("onCheckAll", this.itemsChecked);
    },

    checkItem: function(item) {
      const found = this.itemsChecked.find(
        itemChecked => itemChecked[this.trackBy] === item[this.trackBy]
      );
      if (found) {
        this.itemsChecked = this.itemsChecked.filter(
          itemChecked => itemChecked[this.trackBy] !== item[this.trackBy]
        );
        this.$emit("onUncheckedItem", item);
      } else {
        this.itemsChecked = [...this.itemsChecked, item];
        this.$emit("onCheckedItem", item);
      }
    },

    isCheckedItem: function(item) {
      return !!this.itemsChecked.find(
        itemChecked => itemChecked[this.trackBy] === item[this.trackBy]
      );
    },

    isFieldSortable: function(field) {
      const foundHeader = this.headerFields.find(item => item.name === field);
      return foundHeader && foundHeader.sortable;
    },

    headerItemClass: function(item, className) {
      return item && item.sortable ? className : `${className} no-sortable`;
    },

    isFieldSpecial: field => field.indexOf("__") > -1,

    extractName: string => string.split(":")[0].trim(),

    extractArgs: string => string.split(":")[1],

    bodyColumnWidth: function (item, index) {
      console.log('ITEMMM', item);
      if (item.name === '__slot:checkboxes') {
        return {width: '50px'}
      }
      if (index + 1 === this.data.length || !item.width) {
        // return {width: 'auto'};
        return null
      }

      return {width: `${item.width}px`}
    }
  }
};
</script>
